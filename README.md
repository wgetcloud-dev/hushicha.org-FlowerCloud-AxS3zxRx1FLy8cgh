[合集 \- C\#(80\)](https://github.com)[1\.使用C\#将几个Excel文件合并去重分类2023\-11\-15](https://github.com/mingupupu/p/17833301.html)[2\.C\#使用SqlSugar操作MySQL数据库实现简单的增删改查2023\-11\-16](https://github.com/mingupupu/p/17837125.html)[3\.C\#中的类和继承2023\-11\-17](https://github.com/mingupupu/p/17837924.html)[4\.C\#中的virtual和override关键字2023\-11\-17](https://github.com/mingupupu/p/17837993.html)[5\.C\#中的属性2023\-11\-20](https://github.com/mingupupu/p/17844001.html)[6\.C\#winform中使用SQLite数据库2023\-11\-23](https://github.com/mingupupu/p/17852402.html)[7\.C\#简化工作之实现网页爬虫获取数据2023\-11\-27](https://github.com/mingupupu/p/17860491.html)[8\.C\#中的委托（一）2023\-11\-29](https://github.com/mingupupu/p/17864012.html)[9\.C\#中的ref关键字2023\-11\-29](https://github.com/mingupupu/p/17864054.html)[10\.C\#中out关键字2023\-11\-29](https://github.com/mingupupu/p/17864071.html)[11\.C\#中内置的泛型委托Func与Action2023\-12\-04](https://github.com/mingupupu/p/17876044.html)[12\.在winform blazor hybrid中绘图2023\-12\-13](https://github.com/mingupupu/p/17900024.html)[13\.使用C\#如何监控选定文件夹中文件的变动情况？2023\-12\-28](https://github.com/mingupupu/p/17933098.html)[14\.C\#设计模式之策略模式01\-02](https://github.com/mingupupu/p/17940231)[15\.由浅入深理解C\#中的事件01\-04](https://github.com/mingupupu/p/17946032)[16\.C\#设计模式之观察者模式01\-04](https://github.com/mingupupu/p/17946033)[17\.C\#设计模式之单例模式01\-08](https://github.com/mingupupu/p/17952872)[18\.C\#基于ScottPlot进行可视化01\-13](https://github.com/mingupupu/p/17963079)[19\.C\#使用MiniExcel导入导出数据到Excel/CSV文件02\-10](https://github.com/mingupupu/p/18013077)[20\.winform实现最小化至系统托盘02\-19](https://github.com/mingupupu/p/18022142)[21\.C\#使用Bogus生成测试数据02\-27](https://github.com/mingupupu/p/18036409)[22\.SemanticKernel如何基于自有数据聊天03\-05](https://github.com/mingupupu/p/18054386)[23\.在winform中如何嵌入第三方软件窗体✨03\-07](https://github.com/mingupupu/p/18058334)[24\.在winform中如何实现双向数据绑定？03\-18](https://github.com/mingupupu/p/18080974)[25\.自己动手做一个批量doc转换为docx文件的小工具03\-20](https://github.com/mingupupu/p/18085637)[26\.WPF中动画教程（DoubleAnimation的基本使用）04\-01](https://github.com/mingupupu/p/18108029)[27\.WPF动画教程（PointAnimationUsingPath的使用）04\-03](https://github.com/mingupupu/p/18113095)[28\.C\#使用PaddleOCR进行图片文字识别✨04\-09](https://github.com/mingupupu/p/18124485)[29\.WPF基础：在Canvas上绘制图形04\-16](https://github.com/mingupupu/p/18137691)[30\.WPF/C\#：让绘制的图形可以被选中并将信息显示在ListBox中04\-19](https://github.com/mingupupu/p/18145295)[31\.使用归一化盒过滤器对图像进行平滑处理04\-20](https://github.com/mingupupu/p/18147819)[32\.WPF/C\#：如何显示具有层级关系的数据04\-22](https://github.com/mingupupu/p/18150708)[33\.将彩色图转化为灰度图及其原理介绍04\-23](https://github.com/mingupupu/p/18153025)[34\.WPF/C\#：ProgressBar的基本使用05\-08](https://github.com/mingupupu/p/18179009)[35\.在VB.NET项目中使用C\#编写的代码05\-21](https://github.com/mingupupu/p/18204780)[36\.WPF/C\#：理解与实现WPF中的MVVM模式05\-28](https://github.com/mingupupu/p/18218027)[37\.SemanticKernel：添加插件06\-06](https://github.com/mingupupu/p/18234563)[38\.Avalonia：一个.NET跨平台UI框架06\-10](https://github.com/mingupupu/p/18241078)[39\.WPF/C\#：异常处理06\-12](https://github.com/mingupupu/p/18243650)[40\.WPF/C\#：程序关闭的三种模式06\-12](https://github.com/mingupupu/p/18243656):[樱花宇宙官网](https://yzygzn.com)[41\.wpfui：一个开源免费具有现代化设计趋势的WPF控件库06\-13](https://github.com/mingupupu/p/18245521)[42\.WPF/C\#：如何将数据分组显示06\-17](https://github.com/mingupupu/p/18252701)[43\.WPF/C\#:更改界面的样式06\-17](https://github.com/mingupupu/p/18252711)[44\.LiveCharts2：简单灵活交互式且功能强大的.NET图表库06\-18](https://github.com/mingupupu/p/18253741)[45\.WPF/C\#：显示分组数据的两种方式06\-19](https://github.com/mingupupu/p/18256035)[46\.WPF/C\#：在DataGrid中显示选择框06\-20](https://github.com/mingupupu/p/18258249)[47\.WPF/C\#：数据绑定到方法06\-21](https://github.com/mingupupu/p/18260193)[48\.WPF/C\#：BusinessLayerValidation06\-25](https://github.com/mingupupu/p/18267222)[49\.WPF/C\#：如何实现拖拉元素06\-27](https://github.com/mingupupu/p/18270547)[50\.WPF在.NET9中的重大更新：Windows 11 主题07\-01](https://github.com/mingupupu/p/18277446)[51\.ONNX Runtime入门示例：在C\#中使用ResNet50v2进行图像识别07\-02](https://github.com/mingupupu/p/18279640)[52\.动手学Avalonia：基于SemanticKernel与硅基流动构建AI聊天与翻译工具07\-03](https://github.com/mingupupu/p/18281546)[53\.Avalonia应用在基于Linux的国产操作deepin上运行07\-04](https://github.com/mingupupu/p/18283277)[54\.如何让其他模型也能在SemanticKernel中调用本地函数07\-05](https://github.com/mingupupu/p/18286405)[55\.大语言模型的应用探索—AI Agent初探！07\-08](https://github.com/mingupupu/p/18290420)[56\.动手学Avalonia：基于硅基流动构建一个文生图应用（一）07\-10](https://github.com/mingupupu/p/18294916)[57\.WPF/C\#：在WPF中如何实现依赖注入07\-11](https://github.com/mingupupu/p/18295546)[58\.ScreenToGif：一款开源免费且好用的录屏转Gif软件07\-12](https://github.com/mingupupu/p/18298492)[59\.WPF/C\#：实现导航功能07\-18](https://github.com/mingupupu/p/18309608)[60\.关于学习.NET的历程回顾与今后的探索实践方向07\-24](https://github.com/mingupupu/p/18320722)[61\.入门Vue\+.NET 8 Web Api记录（一）07\-25](https://github.com/mingupupu/p/18322881)[62\.SemanticKernel/C\#：检索增强生成(RAG)简易实践08\-01](https://github.com/mingupupu/p/18336055)[63\.SemanticKernel/C\#：使用Ollama中的对话模型与嵌入模型用于本地离线场景08\-02](https://github.com/mingupupu/p/18339290)[64\.SemanticKernel/C\#：实现接口，接入本地嵌入模型08\-06](https://github.com/mingupupu/p/18344517)[65\.EF Core连接PostgreSQL数据库08\-07](https://github.com/mingupupu/p/18347247)[66\.基于SiliconCloud快速体验GraphRag.Net08\-08](https://github.com/mingupupu/p/18349566)[67\.AvaloniaChat：一个基于大语言模型用于翻译的简单应用08\-16](https://github.com/mingupupu/p/18362777)[68\.最佳实践：在AvaloniaChat中接入SiliconCloud08\-16](https://github.com/mingupupu/p/18362781)[69\.AvaloniaChat—从源码构建指南08\-18](https://github.com/mingupupu/p/18365633)[70\.SimpleRAG：基于WPF与Semantic Kernel实现的一个简单的RAG应用08\-19](https://github.com/mingupupu/p/18367726)[71\.Semantic Kernel/C\#：接入智谱AI的两种方式08\-21](https://github.com/mingupupu/p/18370917)[72\.AvaloniaChat\-v0\.0\.2：兼容智谱AI 快速使用指南08\-21](https://github.com/mingupupu/p/18370914)[73\.使用SiliconCloud快速体验SimpleRAG（手把手教程）08\-22](https://github.com/mingupupu/p/18373908)[74\.使用Ollama本地离线体验SimpleRAG（手把手教程）08\-23](https://github.com/mingupupu/p/18375424)[75\.Semantic Kernel/C\#：一种通用的Function Calling方法，文末附经测试可用的大模型08\-29](https://github.com/mingupupu/p/18385798)[76\.在SimpleRAG中使用SiliconCloud快速测试Function Calling08\-29](https://github.com/mingupupu/p/18385799)[77\.SimpleTranslationAIAgent：基于C\#与LLM的翻译AI Agent08\-31](https://github.com/mingupupu/p/18390206)[78\.SimpleTranslationAIAgent借助SiliconCloud API 构建自己的专属翻译助手08\-31](https://github.com/mingupupu/p/18390207)[79\.SimpleAISearch：C\# \+ DuckDuckGo 实现简单的AI搜索09\-20](https://github.com/mingupupu/p/18422209)80\.SimpleAIAgent：使用免费的glm\-4\-flash即可开始构建简单的AI Agent应用09\-25收起
SimpleAIAgent是基于C\# Semantic Kernel 与 WPF构建的一款AI Agent探索应用。主要用于使用国产大语言模型或开源大语言模型构建AI Agent应用的探索学习，希望能够帮助到感兴趣的朋友。


接下来我想分享一下我的AI Agent应用实践。


## 翻译文本并将文本存入文件


第一个例子是翻译文本，并将文本存入指定的文件。


输入如下内容：


![image-20240925113714519](https://img2024.cnblogs.com/blog/3288240/202409/3288240-20240925123419090-1388674863.png)


**执行过程**


第一步，LLM判断应该调用的函数与参数如下：


![image-20240925113837225](https://img2024.cnblogs.com/blog/3288240/202409/3288240-20240925123419044-989956644.png)


第二步，LLM帮我们调用这个函数，并返回结果：


![image-20240925113939862](https://img2024.cnblogs.com/blog/3288240/202409/3288240-20240925123419039-2144126304.png)


第三步，LLM再次判断需要调用的函数与参数：


![image-20240925114202861](https://img2024.cnblogs.com/blog/3288240/202409/3288240-20240925123419045-1553063124.png)


第四步，LLM调用这个函数，并返回函数返回值：


![image-20240925114250823](https://img2024.cnblogs.com/blog/3288240/202409/3288240-20240925123419063-1299190667.png)


第五步，LLM判断任务已经完成，调用结束函数：


![image-20240925114350284](https://img2024.cnblogs.com/blog/3288240/202409/3288240-20240925123419016-2108389289.png)


第六步，返回最终的回应：


![image-20240925114503461](https://img2024.cnblogs.com/blog/3288240/202409/3288240-20240925123419061-1798768859.png)


**查看结果**


![image-20240925114554332](https://img2024.cnblogs.com/blog/3288240/202409/3288240-20240925123419060-919590121.png)


会发现桌面多了一个文件，打开如下所示：


![image-20240925114623548](https://img2024.cnblogs.com/blog/3288240/202409/3288240-20240925123419098-1481014080.png)


以上AI Agent应用使用glm\-4\-flash即可实现，当然也可以尝试其他模型，模型越强，成功概率越高。


## 实现文件到文件的翻译


输入：


![image-20240925114853823](https://img2024.cnblogs.com/blog/3288240/202409/3288240-20240925123419046-1155375652.png)


文件1\.txt的内容如下：


![image-20240925115006964](https://img2024.cnblogs.com/blog/3288240/202409/3288240-20240925123419106-1566763818.png)


是一段关于WPF的中文描述，现在我想让LLM帮我翻译成英文之后再保存到另一个文件。


同样还是使用免费的glm\-4\-flash


**执行过程**


第一步，LLM判断应该调用的函数与参数如下：


![image-20240925115631597](https://img2024.cnblogs.com/blog/3288240/202409/3288240-20240925123419025-2118952432.png)


第二步，LLM帮我们调用这个函数，并返回结果：


![image-20240925120033177](https://img2024.cnblogs.com/blog/3288240/202409/3288240-20240925123419080-1729216858.png)


第三步，LLM判断任务已经完成，调用结束函数：


![image-20240925115856804](https://img2024.cnblogs.com/blog/3288240/202409/3288240-20240925123419006-1532068081.png)


第四步，返回最终的回应：


![image-20240925115922792](https://img2024.cnblogs.com/blog/3288240/202409/3288240-20240925123419066-1719857498.png)


**查看结果**


![image-20240925120115600](https://img2024.cnblogs.com/blog/3288240/202409/3288240-20240925123419124-1998886546.png)


![image-20240925120135716](https://img2024.cnblogs.com/blog/3288240/202409/3288240-20240925123419118-1614422740.png)


## 实现要点


大家可能会注意到实现的要点其实就是要让LLM自动调用函数，也就是实现自动函数调用的功能。


之后要做的就是根据你想让LLM自动做的事去写插件，然后导入这个插件罢了。


插件中函数最好不要太多，太多模型能力弱的就会乱调用。根据你的需求，实现不同人物导入不同的插件比较好。


插件可以这样写，以上面的翻译插件为例：



```
#pragma warning disable SKEXP0050
    internal class TranslationFunctions
    {
        private readonly Kernel _kernel;
        public TranslationFunctions()
        {
            var handler = new OpenAIHttpClientHandler();
            var builder = Kernel.CreateBuilder()
            .AddOpenAIChatCompletion(
               modelId: ChatAIOption.ChatModel,
               apiKey: ChatAIOption.Key,
               httpClient: new HttpClient(handler));
            _kernel = builder.Build();
        }
        [KernelFunction, Description("选择用户想要的语言翻译文本")]
        public async Task<string> TranslateText(
            [Description("要翻译的文本")] string text,
            [Description("要翻译成的语言，从'中文'、'英文'中选一个")] string language
 )
        {
            string skPrompt = """
                            {{$input}}

                            将上面的文本翻译成{{$language}}，无需任何其他内容
                            """;
            var result = await _kernel.InvokePromptAsync(skPrompt, new() { ["input"] = text, ["language"] = language });
            var str = result.ToString();
            return str;
        }

        [KernelFunction, Description("实现文件到文件的翻译")]
        public async Task<string> TranslateTextFileToFile(
           [Description("要翻译的文件路径")] string path1,
           [Description("保存翻译结果的文件路径")] string path2,
           [Description("要翻译成的语言，从'中文'、'英文'中选一个")] string language
)
        {
            string fileContent = File.ReadAllText(path1);
            var lines = TextChunker.SplitPlainTextLines(fileContent,100);
            var paragraphs = TextChunker.SplitPlainTextParagraphs(lines, 1000);
            string result = "";
            string skPrompt = """
                            {{$input}}

                            将上面的文本翻译成{{$language}}，无需任何其他内容
                            """;
            foreach (var paragraph in paragraphs)
            {
                var result1 = await _kernel.InvokePromptAsync(skPrompt, new() { ["input"] = paragraph, ["language"] = language });
                result += result1.ToString() + "\r\n";
            }        
           
            var str = result.ToString();

            // 使用 StreamWriter 将文本写入文件
            using (StreamWriter writer = new StreamWriter(path2, true))
            {
                writer.WriteLine(str);
            }

            string message = $"已成功实现文件{path1}到文件{path2}的翻译";
            return message;
        }

        [KernelFunction, Description("将文本保存到文件")]
        public string SaveTextToFile(
           [Description("要保存的文本")] string text,
           [Description("要保存到的文件路径")] string filePath
)
        {
            // 使用 StreamWriter 将文本写入文件
            using (StreamWriter writer = new StreamWriter(filePath, true))
            {
                writer.WriteLine(text);
            }
            return "已成功写入文件";
        }

        [KernelFunction, Description("从文件中读取文本")]
        public string GetTextFromFile(
           [Description("要读取的文件路径")] string filePath
)
        {
            string fileContent = File.ReadAllText(filePath);
            return fileContent;
        }

    }

```

就是加上了一些描述用于帮助LLM理解函数的用途罢了，相信对程序员朋友来说不是什么问题，现在就可以动手构建自己的AI Agent应用了。


希望这次的分享对使用LLM构建AI Agent应用感兴趣的朋友有所帮助。


对这个应用感兴趣的朋友，拉一下代码，将appsettings.example.json改为appsettings.json，填入你的API Key与模型名或者使用Ollma填入地址，填入模型名即可快速体验。


GitHub地址：[https://github.com/Ming\-jiayou/SimpleAIAgent](https://github.com)


